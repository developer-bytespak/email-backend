import { Injectable, Logger } from '@nestjs/common';
import { PrismaService } from '../../../config/prisma.service';
import { LlmClientService } from '../../summarization/llm-client/llm-client.service';

export interface SpamCheckResult {
  score: number; // 0-100, higher = more spammy
  keywords: string[];
  suggestions: string[];
  blocked: boolean; // true if score >= threshold
}

export interface OptimizationSuggestions {
  suggestions: string[];
  optimizedContent?: string; // Generated by Gemini if score >= threshold
}

@Injectable()
export class InboxOptimizationService {
  private readonly logger = new Logger(InboxOptimizationService.name);
  private readonly SPAM_THRESHOLD = parseInt(process.env.SPAM_SCORE_THRESHOLD || '50');

  // Expanded spam keywords list
  private readonly spamKeywords = [
    // Urgency/Pressure
    'urgent', 'act now', 'limited time', 'expires soon', 'today only', 'last chance',
    'don\'t miss', 'hurry', 'immediate', 'asap', 'right now',
    
    // Free/Discounts
    'free', 'free gift', 'free trial', '100% free', 'no cost', 'no obligation',
    'discount', 'save', 'special offer', 'limited offer', 'exclusive deal',
    'buy now', 'order now', 'click here', 'call now',
    
    // Money/Financial
    'cash', 'money', 'earn money', 'make money', 'get rich', 'millionaire',
    'guaranteed income', 'risk-free', 'no risk', 'refund guaranteed',
    
    // Suspicious claims
    'miracle', 'secret', 'hidden', 'confidential', 'exclusive', 'insider',
    'winner', 'congratulations', 'you\'ve won', 'prize', 'claim your prize',
    
    // Spam indicators
    'viagra', 'cialis', 'weight loss', 'lose weight fast', 'no credit check',
    'debt consolidation', 'stop foreclosure', 'lower interest rate',
    
    // Clickbait
    'shocking', 'amazing', 'incredible', 'unbelievable', 'you won\'t believe',
    'one weird trick', 'doctors hate', 'this one secret',
    
    // ALL CAPS indicators
    '!!!', '!!!', 'CLICK HERE', 'BUY NOW', 'ACT NOW',
  ];

  constructor(
    private readonly prisma: PrismaService,
    private readonly llmClient: LlmClientService,
  ) {}

  /**
   * Check for spam keywords in content
   */
  checkSpamKeywords(content: string): string[] {
    const lowerContent = content.toLowerCase();
    const foundKeywords: string[] = [];

    for (const keyword of this.spamKeywords) {
      if (lowerContent.includes(keyword.toLowerCase())) {
        foundKeywords.push(keyword);
      }
    }

    return foundKeywords;
  }

  /**
   * Calculate spam score (0-100)
   */
  calculateSpamScore(emailContent: string): number {
    let score = 0;

    // Check for spam keywords (1 point per keyword, max 30 points)
    const foundKeywords = this.checkSpamKeywords(emailContent);
    score += Math.min(foundKeywords.length * 2, 30);

    // Check for excessive capitalization (0-20 points)
    const allCapsRatio = (emailContent.match(/[A-Z]/g) || []).length / emailContent.length;
    if (allCapsRatio > 0.3) {
      score += 20;
    } else if (allCapsRatio > 0.2) {
      score += 10;
    }

    // Check for excessive exclamation marks (0-15 points)
    const exclamationCount = (emailContent.match(/!/g) || []).length;
    if (exclamationCount > 5) {
      score += 15;
    } else if (exclamationCount > 3) {
      score += 10;
    } else if (exclamationCount > 1) {
      score += 5;
    }

    // Check for excessive link density (0-15 points)
    const linkMatches = emailContent.match(/<a\s+href/gi) || [];
    const linkDensity = linkMatches.length / (emailContent.length / 100); // links per 100 chars
    if (linkDensity > 2) {
      score += 15;
    } else if (linkDensity > 1) {
      score += 10;
    }

    // Check for suspicious patterns (0-20 points)
    if (emailContent.includes('!!!') || emailContent.includes('$$$')) {
      score += 10;
    }
    if (emailContent.match(/[A-Z]{5,}/)) { // Words in all caps
      score += 10;
    }

    // Ensure score is between 0-100
    return Math.min(score, 100);
  }

  /**
   * Get optimization suggestions
   */
  getOptimizationSuggestions(content: string, foundKeywords: string[]): string[] {
    const suggestions: string[] = [];

    if (foundKeywords.length > 0) {
      suggestions.push(`Remove or replace spam trigger words: ${foundKeywords.slice(0, 5).join(', ')}`);
    }

    const allCapsRatio = (content.match(/[A-Z]/g) || []).length / content.length;
    if (allCapsRatio > 0.2) {
      suggestions.push('Reduce excessive capitalization. Use sentence case instead.');
    }

    const exclamationCount = (content.match(/!/g) || []).length;
    if (exclamationCount > 2) {
      suggestions.push(`Reduce exclamation marks (found ${exclamationCount}). Use one per email maximum.`);
    }

    const linkMatches = content.match(/<a\s+href/gi) || [];
    if (linkMatches.length > 3) {
      suggestions.push(`Reduce number of links (found ${linkMatches.length}). Use 1-2 links maximum.`);
    }

    if (content.length < 50) {
      suggestions.push('Email is too short. Add more context and value.');
    }

    if (content.length > 500) {
      suggestions.push('Email is too long. Keep it concise (100-300 words).');
    }

    return suggestions;
  }

  /**
   * Check email for spam and get optimization suggestions
   */
  async checkSpamScore(emailContent: string): Promise<SpamCheckResult> {
    const keywords = this.checkSpamKeywords(emailContent);
    const score = this.calculateSpamScore(emailContent);
    const suggestions = this.getOptimizationSuggestions(emailContent, keywords);
    const blocked = score >= this.SPAM_THRESHOLD;

    return {
      score,
      keywords,
      suggestions,
      blocked,
    };
  }

  /**
   * Optimize email content using Gemini AI
   * Called when spam score >= threshold
   */
  async optimizeContentWithGemini(
    originalContent: string, 
    subjectLine: string,
    spamKeywords: string[],
    spamScore: number,
    suggestions: string[]
  ): Promise<OptimizationSuggestions> {
    try {
      const keywordsList = spamKeywords.length > 0 ? spamKeywords.join(', ') : 'None detected';
      const suggestionsList = suggestions.length > 0 ? suggestions.join('\n- ') : 'General optimization needed';

      const prompt = `You are an email optimization expert. The following email has been flagged as potentially spammy.

**SPAM ANALYSIS RESULTS:**
- Spam Score: ${spamScore}/100 (threshold: ${this.SPAM_THRESHOLD})
- Spam Keywords Found: ${keywordsList}
- Specific Issues:
- ${suggestionsList}

**Original Email Subject:** ${subjectLine}

**Original Email Body:**
${originalContent}

**TASK:**
Rewrite the email to address the specific spam issues listed above while maintaining the core message and intent.

**REQUIREMENTS:**
1. Remove or replace the spam trigger words: ${keywordsList}
2. Address each issue from the list above
3. Use professional, natural language
4. Avoid excessive capitalization, exclamation marks, and urgency words
5. Keep the tone friendly but professional
6. Maintain the call-to-action but make it softer and less pushy
7. Keep the email concise (100-200 words)
8. Preserve the original message intent and value proposition

**Output Format (JSON):**
{
  "optimizedSubject": "Optimized subject line",
  "optimizedBody": "Optimized email body text",
  "changes": ["Specific change 1", "Specific change 2", "Specific change 3"]
}

Return ONLY valid JSON, no markdown formatting.`;

      // Use existing Gemini integration
      const GEMINI_API_URL = process.env.GEMINI_API_URL || 'https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash-lite:generateContent';
      const GEMINI_API_KEY = process.env.GEMINI_API_KEY!;

      const response = await fetch(GEMINI_API_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Goog-Api-Key': GEMINI_API_KEY,
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 1024
          }
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.statusText}`);
      }

      const data = await response.json();
      const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';

      // Parse JSON response
      let optimized: any;
      try {
        const cleanText = generatedText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        const jsonMatch = cleanText.match(/\{[\s\S]*\}/);
        optimized = JSON.parse(jsonMatch ? jsonMatch[0] : cleanText);
      } catch (parseError) {
        this.logger.warn('Failed to parse Gemini optimization response, using fallback');
        optimized = {
          optimizedSubject: subjectLine,
          optimizedBody: originalContent,
          changes: ['Unable to generate optimized version automatically']
        };
      }

      return {
        suggestions: optimized.changes || ['Content optimized by AI'],
        optimizedContent: optimized.optimizedBody || originalContent,
      };
    } catch (error) {
      this.logger.error('Failed to optimize content with Gemini:', error);
      return {
        suggestions: ['Failed to generate optimized version. Please edit manually.'],
      };
    }
  }

  /**
   * Get optimization suggestions (with optional Gemini optimization)
   */
  async optimizeContent(emailContent: string, subjectLine?: string): Promise<OptimizationSuggestions> {
    const checkResult = await this.checkSpamScore(emailContent);

    if (checkResult.blocked && subjectLine) {
      // Generate optimized version using Gemini with spam reasons
      const geminiResult = await this.optimizeContentWithGemini(
        emailContent,
        subjectLine,
        checkResult.keywords,
        checkResult.score,
        checkResult.suggestions
      );
      return {
        suggestions: [...checkResult.suggestions, ...geminiResult.suggestions],
        optimizedContent: geminiResult.optimizedContent,
      };
    }

    return {
      suggestions: checkResult.suggestions,
    };
  }

}

