// schema.prisma
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Client {
  id           Int              @id @default(autoincrement())
  name         String
  email        String           @unique
  phone        String
  city         String
  country      String
  address      String
  hashPassword String
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @default(now()) @updatedAt
  csvUploads   CsvUpload[]
  emailDrafts  EmailDraft[]
  emailLogs    EmailLog[]
  products     ProductService[]
  clientEmails ClientEmail[]
  smsDrafts    SmsDraft[]
  smsLogs      SmsLog[]
}

model CsvUpload {
  id                Int             @id @default(autoincrement())
  clientId          Int
  fileName          String
  status            CsvUploadStatus
  totalRecords      Int
  successfulRecords Int
  description       String?
  rawData           Json? // Full CSV data in JSON format
  createdAt         DateTime        @default(now())
  client            Client          @relation(fields: [clientId], references: [id])
  contacts          Contact[]
}

enum CsvUploadStatus {
  success
  failure
}

model Contact {
  id           Int     @id @default(autoincrement())
  csvUploadId  Int
  businessName String
  email        String?
  phone        String?
  website      String?
  state        String?
  zipCode      String?

  // Validation flags for each field
  businessNameValid Boolean @default(false)
  emailValid        Boolean @default(false)
  websiteValid      Boolean @default(false)

  // Overall validity and reason
  valid            Boolean @default(false)
  validationReason String?

  // Scraping strategy
  scrapeMethod   ScrapeMethod?
  scrapePriority Int?

  // Workflow status
  status    ContactStatus @default(new)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @default(now()) @updatedAt

  csvUpload   CsvUpload     @relation(fields: [csvUploadId], references: [id])
  summaries   Summary[]
  emailDrafts EmailDraft[]
  scrapedData ScrapedData[]
  smsDrafts   SmsDraft[]
  emailLogs   EmailLog[]
  smsLogs     SmsLog[]
}

enum ContactStatus {
  new
  validated
  ready_to_scrape
  scraping
  scraped
  scrape_failed
  summarized
  drafted
  sent
  opened
  bounced
}

enum ScrapeMethod {
  direct_url
  email_domain
  business_search
}

model Summary {
  id              Int          @id @default(autoincrement())
  contactId       Int
  summaryText     String
  painPoints      String?
  toneSuggestions String?
  createdAt       DateTime     @default(now())
  contact         Contact      @relation(fields: [contactId], references: [id])
  EmailDraft      EmailDraft[]
  SmsDraft        SmsDraft[]
}

model EmailDraft {
  id               Int              @id @default(autoincrement())
  clientEmailId    Int
  contactId        Int
  summaryId        Int
  subjectLine      String
  bodyText         String
  icebreaker       String?
  productsRelevant String?
  status           EmailDraftStatus @default(draft)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @default(now()) @updatedAt
  clientEmail      ClientEmail      @relation(fields: [clientEmailId], references: [id])
  contact          Contact          @relation(fields: [contactId], references: [id])
  summary          Summary          @relation(fields: [summaryId], references: [id])
  EmailLog         EmailLog[]
  Client           Client?          @relation(fields: [clientId], references: [id])
  clientId         Int?
}

enum EmailDraftStatus {
  draft
  ready
  sent
}

model EmailLog {
  id               Int            @id @default(autoincrement())
  emailDraftId     Int
  contactId        Int
  status           EmailLogStatus
  providerResponse Json?
  sentAt           DateTime
  emailDraft       EmailDraft     @relation(fields: [emailDraftId], references: [id])
  contact          Contact        @relation(fields: [contactId], references: [id])
  Client           Client?        @relation(fields: [clientId], references: [id])
  clientId         Int?
}

enum EmailLogStatus {
  success
  failed
  bounced
}

model ProductService {
  id          Int                 @id @default(autoincrement())
  clientId    Int
  type        ProductServiceType?
  name        String
  description String?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @default(now()) @updatedAt
  client      Client              @relation(fields: [clientId], references: [id])
}

enum ProductServiceType {
  product
  service
}

model ClientEmail {
  id               Int               @id @default(autoincrement())
  clientId         Int
  emailAddress     String
  providerSettings String?
  status           ClientEmailStatus @default(active)
  mailerTestScore  Decimal?          @db.Decimal(5, 2)
  totalCounter     Int               @default(0)
  currentCounter   Int               @default(0)
  timestamp        DateTime?
  limit            Int               @default(500)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @default(now()) @updatedAt
  client           Client            @relation(fields: [clientId], references: [id])
  EmailDraft       EmailDraft[]
}

enum ClientEmailStatus {
  active
  inactive
}

model SmsDraft {
  id               Int            @id @default(autoincrement())
  contactId        Int
  summaryId        Int?
  messageText      String
  productsRelevant String?
  status           SmsDraftStatus @default(draft)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @default(now()) @updatedAt
  contact          Contact        @relation(fields: [contactId], references: [id])
  summary          Summary?       @relation(fields: [summaryId], references: [id])
  SmsLog           SmsLog[]
  Client           Client?        @relation(fields: [clientId], references: [id])
  clientId         Int?
}

enum SmsDraftStatus {
  draft
  ready
  sent
}

model SmsLog {
  id               Int          @id @default(autoincrement())
  smsDraftId       Int
  contactId        Int
  status           SmsLogStatus
  providerResponse Json?
  sentAt           DateTime
  smsDraft         SmsDraft     @relation(fields: [smsDraftId], references: [id])
  contact          Contact      @relation(fields: [contactId], references: [id])
  Client           Client?      @relation(fields: [clientId], references: [id])
  clientId         Int?
}

enum SmsLogStatus {
  success
  failed
  delivered
  undelivered
}

model ScrapedData {
  id            Int          @id @default(autoincrement())
  contactId     Int
  method        ScrapeMethod
  url           String
  searchQuery   String?
  discoveredUrl String?

  // Scraped content (clean text for AI processing)
  homepageText String?
  servicesText String?
  productsText String?
  contactText  String?

  // Raw HTML content (for SEO analysis and reference)
  homepageHtml String?
  servicesHtml String?
  productsHtml String?
  contactHtml  String?

  // Extracted data
  extractedEmails String[]
  extractedPhones String[]

  // Metadata
  pageTitle       String?
  metaDescription String?
  keywords        String[]

  // Status and timing
  scrapeSuccess Boolean  @default(false)
  errorMessage  String?
  scrapedAt     DateTime @default(now())

  // Relations
  contact Contact @relation(fields: [contactId], references: [id])
}
