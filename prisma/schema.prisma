// schema.prisma
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Client {
  id                  Int                  @id @default(autoincrement())
  name                String
  email               String               @unique
  phone               String
  city                String
  country             String
  address             String
  hashPassword        String
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @default(now()) @updatedAt
  csvUploads          CsvUpload[]
  emailDrafts         EmailDraft[]
  emailLogs           EmailLog[]
  products            ProductService[]
  clientEmails        ClientEmail[]
  clientSms           ClientSms[]
  smsDrafts           SmsDraft[]
  smsLogs             SmsLog[]
  senderVerifications SenderVerification[]
}

model CsvUpload {
  id                Int             @id @default(autoincrement())
  clientId          Int
  fileName          String
  status            CsvUploadStatus
  totalRecords      Int
  successfulRecords Int
  description       String?
  rawData           Json? // Full CSV data in JSON format
  createdAt         DateTime        @default(now())
  client            Client          @relation(fields: [clientId], references: [id])
  contacts          Contact[]

  @@index([clientId]) // Critical for JOIN performance in scraping history queries
}

enum CsvUploadStatus {
  success
  failure
}

model Contact {
  id           Int     @id @default(autoincrement())
  csvUploadId  Int
  businessName String
  email        String?
  phone        String?
  website      String?
  state        String?
  zipCode      String?

  // Validation flags for each field
  businessNameValid Boolean @default(false)
  emailValid        Boolean @default(false)
  websiteValid      Boolean @default(false)

  // Overall validity and reason
  valid            Boolean @default(false)
  validationReason String?

  // Scraping strategy
  scrapeMethod   ScrapeMethod?
  scrapePriority Int?

  // Workflow status
  status    ContactStatus @default(new)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @default(now()) @updatedAt

  csvUpload   CsvUpload     @relation(fields: [csvUploadId], references: [id])
  summaries   Summary[]
  emailDrafts EmailDraft[]
  scrapedData ScrapedData[]
  smsDrafts   SmsDraft[]
  emailLogs   EmailLog[]
  smsLogs     SmsLog[]

  // NEW RELATIONS:
  emailEngagements EmailEngagement[]
  emailUnsubscribe EmailUnsubscribe?

  @@index([csvUploadId, businessName])
}

enum ContactStatus {
  new
  validated
  ready_to_scrape
  scraping
  scraped
  scrape_failed
  summarized
  drafted
  sent
  opened
  bounced
}

enum ScrapeMethod {
  direct_url
  email_domain
  business_search
}

model Summary {
  id            Int          @id @default(autoincrement())
  contactId     Int
  scrapedDataId Int? // Link to specific scraped data
  summaryText   String // AI-generated business summary
  painPoints    String[] // Array of identified pain points
  strengths     String[] // Array of business strengths
  opportunities String[] // Array of service opportunities
  keywords      String[] // Array of relevant keywords
  aiModel       String       @default("gemini-2.0-flash-lite") // AI model used
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @default(now()) @updatedAt
  contact       Contact      @relation(fields: [contactId], references: [id])
  scrapedData   ScrapedData? @relation(fields: [scrapedDataId], references: [id])
  EmailDraft    EmailDraft[]
  SmsDraft      SmsDraft[]
}

model EmailDraft {
  id               Int              @id @default(autoincrement())
  clientEmailId    Int?
  contactId        Int
  summaryId        Int
  subjectLines     String[]
  bodyText         String
  icebreaker       String?
  productsRelevant String?
  status           EmailDraftStatus @default(draft)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @default(now()) @updatedAt
  clientEmail      ClientEmail?     @relation(fields: [clientEmailId], references: [id])
  contact          Contact          @relation(fields: [contactId], references: [id])
  summary          Summary          @relation(fields: [summaryId], references: [id])
  EmailLog         EmailLog[]
  EmailQueue       EmailQueue?
  Client           Client           @relation(fields: [clientId], references: [id])
  clientId         Int
}

enum EmailDraftStatus {
  draft
  ready
  sent
}

model EmailLog {
  id               Int            @id @default(autoincrement())
  emailDraftId     Int
  contactId        Int
  status           EmailLogStatus
  providerResponse Json?
  sentAt           DateTime

  // NEW FIELDS:
  messageId          String?   @unique // SendGrid message ID
  trackingPixelToken String?   @unique // Token for custom pixel (backup)
  unsubscribeToken   String?   @unique // Token for unsubscribe link
  sentVia            String    @default("sendgrid")
  deliveredAt        DateTime?
  spamScore          Int? // Pre-send score (0-100)

  // Webhook event tracking fields
  processedAt  DateTime? // When SendGrid processed it
  deferredAt   DateTime? // When email was deferred
  retryAttempt Int? // Retry attempt number (for deferred events)
  smtpId       String? // SMTP transaction ID
  templateId   String? // SendGrid template ID
  customArgs   Json? // Custom arguments as JSON

  emailDraft EmailDraft @relation(fields: [emailDraftId], references: [id])
  contact    Contact    @relation(fields: [contactId], references: [id])
  Client     Client?    @relation(fields: [clientId], references: [id])
  clientId   Int?

  // NEW RELATIONS:
  emailEngagements  EmailEngagement[]
  emailUnsubscribes EmailUnsubscribe[]
}

enum EmailLogStatus {
  success
  failed
  bounced
  pending // NEW
  processed // NEW: SendGrid accepted and queued the email
  deferred // NEW: Temporary failure, retrying
  delivered // NEW
  blocked // NEW
  dropped // NEW
  spamreport // NEW
}

model ProductService {
  id           Int                 @id @default(autoincrement())
  clientId     Int
  type         ProductServiceType?
  name         String
  businessName String
  description  String?
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @default(now()) @updatedAt
  client       Client              @relation(fields: [clientId], references: [id])
}

enum ProductServiceType {
  product
  service
}

model ClientEmail {
  id                 Int                      @id @default(autoincrement())
  clientId           Int
  emailAddress       String
  providerSettings   String?
  status             ClientEmailStatus        @default(active)
  verificationStatus SenderVerificationStatus @default(pending)
  verificationMethod VerificationMethod       @default(otp)
  verifiedAt         DateTime?
  lastOtpSentAt      DateTime?
  mailerTestScore    Decimal?                 @db.Decimal(5, 2)
  totalCounter       Int                      @default(0)
  currentCounter     Int                      @default(0)
  timestamp          DateTime?
  limit              Int                      @default(100)
  createdAt          DateTime                 @default(now())
  updatedAt          DateTime                 @default(now()) @updatedAt

  // NEW FIELDS:
  sendgridApiKey String? // Encrypted SendGrid API key (per email account)

  client              Client               @relation(fields: [clientId], references: [id])
  EmailDraft          EmailDraft[]
  senderVerifications SenderVerification[]
}

enum ClientEmailStatus {
  active
  inactive
}

model ClientSms {
  id                 Int                      @id @default(autoincrement())
  clientId           Int
  phoneNumber        String
  providerSettings   String?
  status             ClientSmsStatus          @default(active)
  verificationStatus SenderVerificationStatus @default(pending)
  verificationMethod VerificationMethod       @default(otp)
  verifiedAt         DateTime?
  lastOtpSentAt      DateTime?
  totalCounter       Int                      @default(0)
  currentCounter     Int                      @default(0)
  timestamp          DateTime?
  limit              Int? // Optional - null means no limit enforcement
  createdAt          DateTime                 @default(now())
  updatedAt          DateTime                 @default(now()) @updatedAt

  client              Client               @relation(fields: [clientId], references: [id])
  smsDrafts           SmsDraft[]
  smsLogs             SmsLog[]
  senderVerifications SenderVerification[]
}

enum ClientSmsStatus {
  active
  inactive
}

model SmsDraft {
  id               Int            @id @default(autoincrement())
  contactId        Int
  summaryId        Int?
  clientSmsId      Int?
  messageText      String
  productsRelevant String?
  status           SmsDraftStatus @default(draft)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @default(now()) @updatedAt
  contact          Contact        @relation(fields: [contactId], references: [id])
  summary          Summary?       @relation(fields: [summaryId], references: [id])
  SmsLog           SmsLog[]
  Client           Client         @relation(fields: [clientId], references: [id])
  clientId         Int
  clientSms        ClientSms?     @relation(fields: [clientSmsId], references: [id])
}

enum SmsDraftStatus {
  draft
  ready
  sent
}

model SmsLog {
  id               Int          @id @default(autoincrement())
  smsDraftId       Int
  contactId        Int
  clientSmsId      Int?
  status           SmsLogStatus
  providerResponse Json?
  sentAt           DateTime
  smsDraft         SmsDraft     @relation(fields: [smsDraftId], references: [id])
  contact          Contact      @relation(fields: [contactId], references: [id])
  Client           Client?      @relation(fields: [clientId], references: [id])
  clientId         Int?
  clientSms        ClientSms?   @relation(fields: [clientSmsId], references: [id])
}

enum SmsLogStatus {
  success
  failed
  delivered
  undelivered
}

model ScrapedData {
  id            Int          @id @default(autoincrement())
  contactId     Int
  method        ScrapeMethod
  url           String
  searchQuery   String?
  discoveredUrl String?

  // Scraped content (clean text for AI processing)
  homepageText String?
  servicesText String?
  productsText String?
  contactText  String?

  // Raw HTML content (for SEO analysis and reference)
  homepageHtml String?
  servicesHtml String?
  productsHtml String?
  contactHtml  String?

  // Extracted data
  extractedEmails String[]
  extractedPhones String[]

  // Metadata
  pageTitle       String?
  metaDescription String?
  keywords        String[]

  // Status and timing
  scrapeSuccess Boolean  @default(false)
  errorMessage  String?
  scrapedAt     DateTime @default(now())

  // Relations
  contact   Contact   @relation(fields: [contactId], references: [id])
  summaries Summary[]

  @@index([contactId, scrapedAt], map: "ScrapedData_contactId_scrapedAt_idx")
  @@index([scrapeSuccess], map: "ScrapedData_scrapeSuccess_idx")
  @@index([method, scrapedAt], map: "ScrapedData_method_scrapedAt_idx")
}

// ==========================================
// NEW TABLES FOR EMAIL AUTOMATION
// ==========================================

model EmailEngagement {
  id             Int            @id @default(autoincrement())
  emailLogId     Int
  contactId      Int
  engagementType EngagementType // 'open' OR 'click' - separate records per event
  engagedAt      DateTime       @default(now())
  url            String? // Only for clicks - original URL clicked

  emailLog EmailLog @relation(fields: [emailLogId], references: [id], onDelete: Cascade)
  contact  Contact  @relation(fields: [contactId], references: [id])

  @@index([emailLogId])
  @@index([contactId])
  @@index([engagementType, engagedAt])
}

enum EngagementType {
  open // Created when tracking pixel loads or SendGrid webhook
  click // Created when link is clicked or SendGrid webhook
}

model SenderVerification {
  id                 Int                      @id @default(autoincrement())
  senderType         SenderType
  clientId           Int // Store clientId for temporary verifications
  clientEmailId      Int?
  clientSmsId        Int?
  emailAddress       String? // Temporary storage before ClientEmail is created
  phoneNumber        String? // Temporary storage before ClientSms is created
  otpHash            String
  otpExpiresAt       DateTime
  attemptCount       Int                      @default(0)
  status             SenderVerificationStatus @default(pending)
  verificationMethod VerificationMethod       @default(otp)
  verifiedAt         DateTime?
  lastOtpSentAt      DateTime?
  createdAt          DateTime                 @default(now())
  updatedAt          DateTime                 @default(now()) @updatedAt

  client      Client       @relation(fields: [clientId], references: [id])
  clientEmail ClientEmail? @relation(fields: [clientEmailId], references: [id])
  clientSms   ClientSms?   @relation(fields: [clientSmsId], references: [id])

  @@unique([clientEmailId], map: "senderVerification_clientEmailId_key")
  @@unique([clientSmsId], map: "senderVerification_clientSmsId_key")
  @@index([clientId, emailAddress, status]) // For finding pending email verifications
  @@index([clientId, phoneNumber, status]) // For finding pending SMS verifications
}

enum SenderType {
  email
  sms
}

enum SenderVerificationStatus {
  pending
  verified
  expired
  rejected
}

enum VerificationMethod {
  otp
}

model EmailUnsubscribe {
  id                    Int      @id @default(autoincrement())
  contactId             Int      @unique // One unsubscribe per contact
  unsubscribeEmailLogId Int? // Which email triggered unsubscribe
  unsubscribedAt        DateTime @default(now())
  reason                String? // Optional reason

  contact  Contact   @relation(fields: [contactId], references: [id], onDelete: Cascade)
  emailLog EmailLog? @relation(fields: [unsubscribeEmailLogId], references: [id])

  @@index([contactId])
}

model EmailQueue {
  id           Int              @id @default(autoincrement())
  emailDraftId Int              @unique // One queue entry per draft
  scheduledAt  DateTime
  status       EmailQueueStatus @default(pending)
  retryCount   Int              @default(0)
  nextRetryAt  DateTime? // When to retry if failed
  priority     Int              @default(0) // Lower = higher priority (FIFO)
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @default(now()) @updatedAt

  emailDraft EmailDraft @relation(fields: [emailDraftId], references: [id], onDelete: Cascade)

  @@index([status, scheduledAt, priority]) // For FIFO queue queries
}

enum EmailQueueStatus {
  pending
  sent
  failed
}
